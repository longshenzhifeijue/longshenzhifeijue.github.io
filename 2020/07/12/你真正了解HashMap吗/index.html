

<!DOCTYPE html>
<html lang="en" color-mode=light>
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1, maximum-scale=1, user-scalable=no">
  <meta http-equiv="X-UA-Compatible" content="ie=edge">
  <title>你真正了解HashMap吗 - Hexo</title>
  <meta name="apple-mobile-web-app-capable" content="yes" />
  <meta name="apple-mobile-web-app-status-bar-style" content="black-translucent">
  <meta name="google" content="notranslate" />
  
  <meta name="description" content="HashMap面试题，看这一篇就够了



在后端的日...">
  <meta name="author" content="John Doe">
  <link rel="icon" href="/images/icons/favicon-16x16.png" type="image/png" sizes="16x16">
  <link rel="icon" href="/images/icons/favicon-32x32.png" type="image/png" sizes="32x32">
  <link rel="apple-touch-icon" href="/images/icons/apple-touch-icon.png" sizes="180x180">
  <meta rel="mask-icon" href="/images/icons/stun-logo.svg" color="#333333">
  
    <meta rel="msapplication-TileImage" content="/images/icons/favicon-144x144.png">
    <meta rel="msapplication-TileColor" content="#000000">
  

  
<link rel="stylesheet" href="/css/style.css">


  
    
<link rel="stylesheet" href="//at.alicdn.com/t/font_1445822_r673sha78lq.css">

  

  
    
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.css">

  

  
    
      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/xcode.min.css" name="highlight-style" mode="light">

      
        
        
<link rel="stylesheet" href="https://cdn.bootcss.com/highlight.js/9.18.1/styles/solarized-dark.min.css" name="highlight-style" mode="dark">

      
  

  <script>
    var CONFIG = window.CONFIG || {};
    var ZHAOO = window.ZHAOO || {};
    CONFIG = {
      isHome: false,
      fancybox: true,
      pjax: false,
      lazyload: {
        enable: false,
        only_post: 'false',
        loading: '[object Object]'
      },
      donate: {
        enable: true,
        alipay: 'https://pic.izhaoo.com/alipay.jpg',
        wechat: 'https://pic.izhaoo.com/wechat.jpg'
      },
      galleries: {
        enable: true
      },
      fab: {
        enable: true,
        always_show: false
      },
      carrier: {
        enable: true
      },
      daovoice: {
        enable: false
      },
      preview: {
        background: {
          default: '',
          api: ''
        },
        motto: {
          default: '真正的大师，永远怀着一颗学徒的心',
          typing: false,
          api: '',
          data_contents: '["data","content"]'
        },
      },
      qrcode: {
        enable: true,
        type: 'url',
        image: 'https://pic.izhaoo.com/weapp-code.jpg',
      },
      toc: {
        enable: true
      },
      scrollbar: {
        type: 'default'
      },
      notification: {
        enable: false,
        delay: 4500,
        list: '',
        page_white_list: '',
        page_black_list: ''
      },
      search: {
        enable: false,
        path: ''
      }
    }
  </script>

  

  

<meta name="generator" content="Hexo 5.4.0"></head>

<body class="lock-screen">
  <div class="loading"></div>
  
    


  <nav class="navbar">
    <div class="left">
      
        <i class="iconfont iconhome j-navbar-back-home"></i>
      
      
        <i class="iconfont iconqrcode j-navbar-qrcode"></i>
      
      
        <i class="iconfont iconmoono" id="color-toggle" color-toggle="light"></i>
      
      
    </div>
    <div class="center">你真正了解HashMap吗</div>
    <div class="right">
      <i class="iconfont iconmenu j-navbar-menu"></i>
    </div>
    
      <div id="qrcode-navbar"></div>
    
  </nav>

  
  

<nav class="menu">
  <div class="menu-container">
    <div class="menu-close">
      <i class="iconfont iconbaseline-close-px"></i>
    </div>
    <ul class="menu-content"><li class="menu-item">
        <a href="/ " class="underline "> 首页</a>
      </li><li class="menu-item">
        <a href="/galleries/ " class="underline "> 摄影</a>
      </li><li class="menu-item">
        <a href="/archives/ " class="underline "> 归档</a>
      </li><li class="menu-item">
        <a href="/tags/ " class="underline "> 标签</a>
      </li><li class="menu-item">
        <a href="/categories/ " class="underline "> 分类</a>
      </li><li class="menu-item">
        <a href="/about/ " class="underline "> 关于</a>
      </li></ul>
    
      <div class="menu-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/longshenzhifeijue">XuFei</a></p></div>
    
  </div>
</nav>
  <main id="main">
  <div class="article-wrap">
    <div class="row container">
      <div class="col-xl-3"></div>
      <div class="col-xl-6"><article class="article">
  <div class="wrap">
    <section class="head">
  <img src="/images/theme/post-image.jpg" draggable="false">
  <div class="head-mask">
    <h1 class="head-title">你真正了解HashMap吗</h1>
    <div class="head-info">
      <span class="post-info-item"><i class="iconfont iconcalendar"></i>July 12, 2020</span>
      
      <span class="post-info-item"><i class="iconfont iconfont-size"></i>26306</span>
    </div>
  </div>
</section>
    <section class="main">
      <section class="content">
        <p>在后端的日常开发工作中，<strong>集合</strong>是使用频率相当高的一个工具，而其中的<strong>HashMap</strong>，则更是我们用以处理业务逻辑的好帮手，同时<strong>HashMap</strong>的底层实现和原理，也成了面试题中的常客。</p>
<p>以前曾有详细了解过<strong>HashMap</strong>的实现原理，看过源码（JDK7版本）。但随着jdk版本的飞速迭代（现在都到JDK13了，但新特性还从没用过。。），主流的jdk使用版本也终于从JDK7挪到了JDK8。</p>
<p>由于JDK的向前兼容，在JDK8的使用过程中也没发现<strong>HashMap</strong>有什么特别之处，特性并无变化（依然线程不安全）。但最近的一次好奇心驱使，从IDE中点进去看了下<strong>HashMap</strong>的**<code>put()</code><strong>方法，有点儿懵逼，怎么跟我记忆中的不太一样？从JDK7到JDK8，</strong>HashMap**也做了升级么？升级了什么哪些内容？</p>
<p>借着这股好奇心，把JDK7和JDK8的源码都翻了翻，对两者的实现原理做一下对比，JDK版本都在半年左右一次的速度推陈出新，我们的认知当然也要跟上，不断学习，站在浪潮之巅，不然就要被这滚滚的信息泥石流给裹挟淹没了。</p>
<p>先展示下Map家族的关系层级，有助于我们更好的理解后面的内容。</p>
<p><img  src="https://user-gold-cdn.xitu.io/2019/12/5/16ed3af3b2c59ed6?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">img</span></p>
<p><strong>HashMap</strong>的基本知识点介绍就不多啰嗦了，直奔主题，看JDK7和JDK8的功能实现吧。</p>
<h1 id="一、JDK7中的HashMap底层实现"><a href="#一、JDK7中的HashMap底层实现" class="headerlink" title="一、JDK7中的HashMap底层实现"></a>一、JDK7中的HashMap底层实现</h1><h2 id="1-1-基础知识"><a href="#1-1-基础知识" class="headerlink" title="1.1 基础知识"></a>1.1 基础知识</h2><p>不管是1.7，还是1.8，HashMap的实现框架都是<strong>哈希表 + 链表</strong>的组合方式。结构图如下：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2019/12/5/16ed3af3b45739c9?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">img</span></p>
<p>平常使用最多的就是**<code>put()</code><strong>、</strong><code>get()</code><strong>操作，想要了解底层实现，最直接的就是从</strong><code>put()/get()</code>**方法看起。不过在具体看源码前，我们先关注几个域变量，打打基础，如下：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2019/12/5/16ed3af3b43f614f?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">img</span></p>
<p>上图中，已对各个变量做了简单的解释。 再多说一下，最后一个变量**<code>modCount</code><strong>，记录了map新增/删除k-v对，或者内部结构做了调整的次数，其主要作用，是对Map的</strong><code>iterator()</code><strong>操作做一致性校验，如果在iterator操作的过程中，map的数值有修改，直接抛出</strong><code>ConcurrentModificationException</code>**异常。</p>
<p>还需要说明的是，上面的域变量中存在一个等式：</p>
<figure class="highlight sas"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><code class="hljs sas">threshold = <span class="hljs-meta">table</span>.<span class="hljs-meta">length</span> <span class="hljs-comment">* loadFactor;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>当执行**<code>put()</code><strong>操作放入一个新的值时，如果map中已经存在对应的key，则作替换即可，若不存在，则会首先判断</strong><code>size&gt;=threshold</code>**是否成立，这是决定哈希table是否扩容的重要因素。</p>
<p>就使用层面来说，用的最多的莫过于**<code>put()</code><strong>方法、</strong><code>get()</code>**方法。想要详细了解运作原理，那就先从这两个方法看起吧，这两个方法弄明白了，也就基本能理清HashMap的实现原理了。</p>
<h2 id="1-2-put-方法"><a href="#1-2-put-方法" class="headerlink" title="1.2 put()方法"></a>1.2 put()方法</h2><p>当了解了以上的变量和用途后，接下来看下**<code>put()</code>**方法的具体实现：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2019/12/5/16ed3af3b5ad0137?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">img</span></p>
<p>如上面的截图代码所示，整个put方法的处理过程，可拆分为四部分：</p>
<ul>
<li><strong>part1：特殊key值处理，key为null；</strong></li>
<li><strong>part2：计算table中目标bucket的下标；</strong></li>
<li><strong>part3：指定目标bucket，遍历Entry结点链表，若找到key相同的Entry结点，则做替换；</strong></li>
<li><strong>part4：若未找到目标Entry结点，则新增一个Entry结点。</strong></li>
</ul>
<p>不知大家有没有发现，上面截图中的**<code>put()</code>**方法是有返回值的，场景区分如下：</p>
<ul>
<li>场景1：若执行put操作前，key已经存在，那么在执行put操作时，会使用本次的新value值来覆盖前一次的旧value值，返回的就是旧value值；</li>
<li>场景2：若key不存在，则返回null值。</li>
</ul>
<p>下面对put方法的各部分做详细的拆解分析。</p>
<h3 id="1-2-1-特殊key值处理"><a href="#1-2-1-特殊key值处理" class="headerlink" title="1.2.1 特殊key值处理"></a>1.2.1 特殊key值处理</h3><p>特殊key值，指的就是key为null。 先说结论：<br> <strong>a)</strong> HashMap中，是允许key、value都为null的，且key为null只存一份，多次存储会将旧value值覆盖；<br> <strong>b)</strong> key为null的存储位置，都统一放在下标为<strong>0</strong>的bucket，即：table[0]位置的链表；<br> <strong>c)</strong> 如果是第一次对key=null做put操作，将会在table[0]的位置新增一个Entry结点，使用头插法做链表插入。</p>
<p>上代码：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-keyword">private</span> V put<span class="hljs-constructor">ForNullKey(V <span class="hljs-params">value</span>)</span> &#123;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table<span class="hljs-literal">[<span class="hljs-number">0</span>]</span>; e != null; e = e.next) &#123;<br>        <span class="hljs-keyword">if</span> (e.key<span class="hljs-operator"> == </span>null) &#123;<br>            V oldValue = e.value;<br>            e.value = value;<br>            e.record<span class="hljs-constructor">Access(<span class="hljs-params">this</span>)</span>;<br>            return oldValue;<br>        &#125;<br>    &#125;<br>    modCount++;<br>    add<span class="hljs-constructor">Entry(0, <span class="hljs-params">null</span>, <span class="hljs-params">value</span>, 0)</span>;<br>    return null;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Adds a new entry with the specified key, value and hash code to</span><br><span class="hljs-comment"> * the specified bucket.  It is the responsibility of this</span><br><span class="hljs-comment"> * method to resize the table if appropriate.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of put method.</span><br><span class="hljs-comment"> */</span><br>void add<span class="hljs-constructor">Entry(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">int</span> <span class="hljs-params">bucketIndex</span>)</span> &#123;<br>    <span class="hljs-keyword">if</span> ((size &gt;= threshold)<span class="hljs-operator"> &amp;&amp; </span>(null != table<span class="hljs-literal">[<span class="hljs-identifier">bucketIndex</span>]</span>)) &#123;<br>        resize(<span class="hljs-number">2</span><span class="hljs-operator"> * </span>table.length);<br>        hash = (null != key) ? hash(key) : <span class="hljs-number">0</span>;<br>        bucketIndex = index<span class="hljs-constructor">For(<span class="hljs-params">hash</span>, <span class="hljs-params">table</span>.<span class="hljs-params">length</span>)</span>;<br>    &#125;<br><br><br>    create<span class="hljs-constructor">Entry(<span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>, <span class="hljs-params">bucketIndex</span>)</span>;<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Like addEntry except that this version is used when creating entries</span><br><span class="hljs-comment"> * as part of Map construction or &quot;pseudo-construction&quot; (cloning,</span><br><span class="hljs-comment"> * deserialization).  This version needn&#x27;t worry about resizing the table.</span><br><span class="hljs-comment"> *</span><br><span class="hljs-comment"> * Subclass overrides this to alter the behavior of HashMap(Map),</span><br><span class="hljs-comment"> * clone, and readObject.</span><br><span class="hljs-comment"> */</span><br>void create<span class="hljs-constructor">Entry(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">int</span> <span class="hljs-params">bucketIndex</span>)</span> &#123;<br>    Entry&lt;K,V&gt; e = table<span class="hljs-literal">[<span class="hljs-identifier">bucketIndex</span>]</span>;<br>    table<span class="hljs-literal">[<span class="hljs-identifier">bucketIndex</span>]</span> = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<br>    size++;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>**<code>putForNullKey()</code><strong>方法中的代码较为简单：首先选择</strong>table[0]**位置的链表，然后对链表做遍历操作，如果有结点的key为null，则将新value值替换掉旧value值，返回旧value值，如果未找到，则新增一个key为null的Entry结点。</p>
<p>重点我们看下第二个方法**<code>addEntry()</code>**。 这是一个通用方法：</p>
<blockquote>
<p>给定hash、key、value、bucket下标，新增一个Entry结点，另外还担负了扩容职责。如果哈希表中存放的k-v对数量超过了当前阈值(<strong>threshold = table.length * loadFactor</strong>)，且当前的bucket下标有链表存在，那么就做扩容处理（resize）。扩容后，重新计算hash，最终得到新的bucket下标，然后使用头插法新增结点。</p>
</blockquote>
<h3 id="1-2-2-扩容"><a href="#1-2-2-扩容" class="headerlink" title="1.2.2 扩容"></a>1.2.2 扩容</h3><p>上一节有提及，当k-v对的容量超出一定限度后，需要对哈希table做扩容操作。那么问题来了，怎么扩容的？ 下面看下源代码：</p>
<p><img  src="https://user-gold-cdn.xitu.io/2019/12/5/16ed3af3b62bb33d?imageView2/0/w/1280/h/960/format/webp/ignore-error/1"  ><span class="image-caption">img</span></p>
<p>有两个核心点： <strong>a)</strong> 扩容后大小是扩容前的2倍；</p>
<figure class="highlight abnf"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs abnf"><span class="hljs-attribute">oldCapacity</span>=table.length<span class="hljs-comment">;</span><br><span class="hljs-attribute">newCapacity</span> = <span class="hljs-number">2</span> * oldCapacity<span class="hljs-comment">;</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p><strong>b)</strong> 数据搬迁，从旧table迁到扩容后的新table。 为避免碰撞过多，先决策是否需要对每个Entry链表结点重新hash，然后根据hash值计算得到bucket下标，然后使用头插法做结点迁移。</p>
<h3 id="1-2-3-如何计算bucket下标？"><a href="#1-2-3-如何计算bucket下标？" class="headerlink" title="1.2.3 如何计算bucket下标？"></a>1.2.3 如何计算bucket下标？</h3><h4 id="①-hash值的计算"><a href="#①-hash值的计算" class="headerlink" title="① hash值的计算"></a>① hash值的计算</h4><p>首先得有key的hash值，就是一个整数，int类型，其计算方式使用了一种可尽量减少碰撞的算式（高位运算），具体原理不再展开，只要知道一点就行：使用key的hashCode作为算式的输入，得到了hash值。</p>
<p>从以上知识点，我们可以得到一个<strong>推论</strong>：<br> <strong>对于两个对象，若其hashCode相同，那么两个对象的hash值就一定相同。</strong></p>
<p>这里还牵涉到另外一个知识点。对于HashMap中key的类型，必须满足以下的条件：<br> <strong>若两个对象逻辑相等，那么他们的hashCode一定相等，反之却不一定成立。</strong></p>
<p>逻辑相等的含义就比较宽泛了，我们可以将逻辑的相等定义为两个对象的内存地址相同，也可以定义为对象的某个域值相等，自定义两个对象的逻辑相等，可通过重写**<code>Object</code><strong>类的</strong><code>equals()</code><strong>方法来实现。 比如</strong><code>String</code>**类，请看以下代码：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>System.out.<span class="hljs-built_in">println</span>(str1 == str2);  <span class="hljs-comment">// false，两个对象的内存地址并不同</span><br>System.out.<span class="hljs-built_in">println</span>(str1.<span class="hljs-built_in">equals</span>(str2)); <span class="hljs-comment">// true 两个对象的域值相同，都存储了 abc 这三个字符</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>对于上面代码中的**<code>str1</code><strong>、</strong><code>str2</code><strong>两个对象，虽然它们的内存地址不同，但根据</strong><code>String</code><strong>类中对</strong><code>Object</code><strong>类的</strong><code>equals()</code><strong>方法的重写(</strong>@override**)，两个对象的域变量（即char数组）都存储了’a’、’b’、’c’三个字符，因此逻辑上是相等的。既然**<code>str1</code><strong>、</strong><code>str2</code>**两个对象逻辑上相等，那么一定有如下结果：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs reasonml"><span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(str1.hash<span class="hljs-constructor">Code()</span><span class="hljs-operator"> == </span>str2.hash<span class="hljs-constructor">Code()</span>);<br><br><br>---输出---<br><span class="hljs-literal">true</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>从而我们就可以知道，在同一个HashMap对象中，会有如下结果：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs arduino"><span class="hljs-keyword">String</span> str1 = <span class="hljs-string">&quot;abc&quot;</span>;<br><span class="hljs-keyword">String</span> str2 = <span class="hljs-keyword">new</span> <span class="hljs-built_in"><span class="hljs-keyword">String</span></span>(<span class="hljs-string">&quot;abc&quot;</span>);<br>Map&lt;<span class="hljs-keyword">String</span>, Integer&gt; testMap = <span class="hljs-keyword">new</span> HashMap&lt;&gt;();<br>testMap.<span class="hljs-built_in">put</span>(str1, <span class="hljs-number">12</span>);<br>testMap.<span class="hljs-built_in">put</span>(str2, <span class="hljs-number">13</span>);<br><br><br><span class="hljs-keyword">String</span> str3 = <span class="hljs-keyword">new</span> <span class="hljs-built_in">StringBuilder</span>(<span class="hljs-string">&quot;ab&quot;</span>).<span class="hljs-built_in">append</span>(<span class="hljs-string">&quot;c&quot;</span>).<span class="hljs-built_in">toString</span>();<br>System.out.<span class="hljs-built_in">println</span>(testMap.<span class="hljs-built_in">get</span>(str3));<br><br><br>---输出---<br><span class="hljs-number">13</span><br>复制代码<br></code></pre></td></tr></table></figure>

<p>另外，我们也可以反过来想一下。</p>
<p>假设HashMap的key不满足上面提到的条件，即：两个对象相等的情况下，他们的hashCode可能不一致。那么，这会带来什么后果呢？以上面示例代码中的**<code>str1</code><strong>、</strong><code>str2</code><strong>为例，若它们的hashCode不相等，那么对应的hash也就可能不相等（</strong>注意<strong>：这里是</strong>可能不相等<strong>，也有可能相等），testMap做put操作时，</strong><code>str1</code><strong>、</strong><code>str2</code><strong>为就会被分配到不同的bucket上，导致的最直接后果就是会存储两份。间接的后果那就更多了，比如：使用</strong><code>str3</code><strong>对象执行</strong><code>testMap.get(str3)</code><strong>操作时，可能获取不到值，更进一步的后果就是这部分无法触达的对象无法回收，导致</strong>内存泄漏**。</p>
<p>因此，<strong>再重新一遍</strong>，HashMap的key所对应的类型，一定要满足如下条件：<br> <strong>若两个对象逻辑相等，那么他们的hashCode一定相等，反之却不一定成立。</strong></p>
<h4 id="②-取模的逻辑"><a href="#②-取模的逻辑" class="headerlink" title="② 取模的逻辑"></a>② 取模的逻辑</h4><p>前面我们分析了hash值的计算，接下来就可以引出bucket下标的计算：</p>
<figure class="highlight cpp"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs cpp"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns index for hash code h.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-function"><span class="hljs-keyword">static</span> <span class="hljs-keyword">int</span> <span class="hljs-title">indexFor</span><span class="hljs-params">(<span class="hljs-keyword">int</span> h, <span class="hljs-keyword">int</span> length)</span> </span>&#123;<br>    <span class="hljs-keyword">return</span> h &amp; (length<span class="hljs-number">-1</span>);<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>计算相当简洁：将table的容量与hash值做“<strong>与</strong>”运算，得到哈希table的bucket下标。</p>
<h4 id="③-拓展"><a href="#③-拓展" class="headerlink" title="③ 拓展"></a>③ 拓展</h4><p>这种通俗的不能再通俗的计算大家都能看懂，但为何要这样做呢？背后的思考是什么？在看到下面的解释前，大家可以先思考下~</p>
<p>在文档开头，给出了HashMap类中的各个域变量。其中，哈希table的初始大小默认设置为16，为2的次幂数。后面在扩容时，都是以2的倍数来扩容。为什么非要将哈希table的大小控制为2的次幂数？</p>
<p><strong>原因1</strong>：降低发生碰撞的概率，使散列更均匀。根据key的hash值计算bucket的下标位置时，使用“与”运算公式：h &amp; (length-1)，当哈希表长度为2的次幂时，等同于使用表长度对hash值取模（不信大家可以自己演算一下），散列更均匀；<br> <strong>原因2</strong>：表的长度为2的次幂，那么(length-1)的二进制最后一位一定是1，在对hash值做“与”运算时，最后一位就可能为1，也可能为0，换句话说，取模的结果既有偶数，又有奇数。设想若(length-1)为偶数，那么“与”运算后的值只能是0，奇数下标的bucket就永远散列不到，会浪费一半的空间。</p>
<h3 id="1-2-4-在目标bucket中遍历Entry结点"><a href="#1-2-4-在目标bucket中遍历Entry结点" class="headerlink" title="1.2.4 在目标bucket中遍历Entry结点"></a>1.2.4 在目标bucket中遍历Entry结点</h3><p>先把这部分代码拎出来：</p>
<figure class="highlight stan"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs stan">...<br><span class="hljs-keyword">int</span> i = indexFor(hash, table.length);<br><span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; <span class="hljs-built_in">e</span> = table[i]; <span class="hljs-built_in">e</span> != null; <span class="hljs-built_in">e</span> = <span class="hljs-built_in">e</span>.next) &#123;<br>    Object k;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">e</span>.hash == hash &amp;&amp; ((k = <span class="hljs-built_in">e</span>.key) == key || key.equals(k))) &#123;<br>        V oldValue = <span class="hljs-built_in">e</span>.value;<br>        <span class="hljs-built_in">e</span>.value = value;<br>        <span class="hljs-built_in">e</span>.recordAccess(this);<br>        <span class="hljs-keyword">return</span> oldValue;<br>    &#125;<br>&#125;<br>...<br>复制代码<br></code></pre></td></tr></table></figure>

<p>通过hash值计算出下标，找到对应的目标bucket，然后对链表做遍历操作，逐个比较，如下：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="815"></svg>)</p>
<p>注意这里的查找条件：**<code>e.hash == hash &amp;&amp; ((k = e.key) == key || key.equals(k))</code>** 结点的key与目标key的相等，要么内存地址相等，要么逻辑上相等，两者有一个满足即可。</p>
<h2 id="1-3-get-方法"><a href="#1-3-get-方法" class="headerlink" title="1.3 get()方法"></a>1.3 get()方法</h2><p>相比于**<code>put()</code><strong>方法，</strong><code>get()</code>**方法的实现就相对简单多了。主要分为两步，先是通过key的hash值计算目标bucket的下标，然后遍历对应bucket上的链表，逐个对比，得到结果。</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-keyword">if</span> (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>)<br>        <span class="hljs-keyword">return</span> getForNullKey();<br>    Entry&lt;K,V&gt; entry = getEntry(<span class="hljs-built_in">key</span>);<br><br><br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span> == entry ? <span class="hljs-keyword">null</span> : entry.getValue();<br>&#125;<br><br><br><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Returns the entry associated with the specified key in the</span><br><span class="hljs-comment"> * HashMap.  Returns null if the HashMap contains no mapping</span><br><span class="hljs-comment"> * for the key.</span><br><span class="hljs-comment"> */</span><br><span class="hljs-keyword">final</span> Entry&lt;K,V&gt; getEntry(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>    <span class="hljs-built_in">int</span> hash = (<span class="hljs-built_in">key</span> == <span class="hljs-keyword">null</span>) ? <span class="hljs-number">0</span> : hash(<span class="hljs-built_in">key</span>);<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e = table[indexFor(hash, table.length)];<br>         e != <span class="hljs-keyword">null</span>;<br>         e = e.next) &#123;<br>        <span class="hljs-keyword">Object</span> k;<br>        <span class="hljs-keyword">if</span> (e.hash == hash &amp;&amp;<br>            ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-keyword">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            <span class="hljs-keyword">return</span> e;<br>    &#125;<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="1-4-Map中的迭代器Iterator"><a href="#1-4-Map中的迭代器Iterator" class="headerlink" title="1.4 Map中的迭代器Iterator"></a>1.4 Map中的迭代器Iterator</h2><h3 id="1-4-1-Map遍历的几种方式"><a href="#1-4-1-Map遍历的几种方式" class="headerlink" title="1.4.1 Map遍历的几种方式"></a>1.4.1 Map遍历的几种方式</h3><p>先问个问题，你能想到几种遍历Map的方式？</p>
<h4 id="方式1：Iterator迭代器"><a href="#方式1：Iterator迭代器" class="headerlink" title="方式1：Iterator迭代器"></a>方式1：Iterator迭代器</h4><figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Iterator</span>&lt;Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt;&gt; <span class="hljs-built_in">iterator</span> = testMap.entrySet().<span class="hljs-built_in">iterator</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">iterator</span>.hasNext()) &#123;<br>    Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt; next = <span class="hljs-built_in">iterator</span>.next();<br>    System.out.println(next.getKey() + <span class="hljs-string">&quot;:&quot;</span> + next.getValue());<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>逐个获取哈希table中的每个bucket中的每个Entry结点，后面会详细介绍。</p>
<h4 id="方式2：最常见的使用方式，可同时得到key、value值"><a href="#方式2：最常见的使用方式，可同时得到key、value值" class="headerlink" title="方式2：最常见的使用方式，可同时得到key、value值"></a>方式2：最常见的使用方式，可同时得到key、value值</h4><figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs ada">// 方式一<br><span class="hljs-keyword">for</span> (Map.<span class="hljs-keyword">Entry</span>&lt;String, Integer&gt; <span class="hljs-keyword">entry</span> : <span class="hljs-type">testMap.entrySet</span>()) &#123;<br>    System.<span class="hljs-keyword">out</span>.println(<span class="hljs-keyword">entry</span>.getKey() + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">entry</span>.getValue());<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这种方式是一个语法糖，我们可通过反编译命令javap，或通过IDE来查下编译之后的语句：</p>
<figure class="highlight ada"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs ada">Iterator var2 = testMap.entrySet().iterator();<br><span class="hljs-keyword">while</span>(var2.hasNext()) &#123;<br>    <span class="hljs-keyword">Entry</span>&lt;String, Integer&gt; <span class="hljs-keyword">entry</span> = (<span class="hljs-keyword">Entry</span>)var2.next();<br>    System.<span class="hljs-keyword">out</span>.println((String)<span class="hljs-keyword">entry</span>.getKey() + <span class="hljs-string">&quot;:&quot;</span> + <span class="hljs-keyword">entry</span>.getValue());<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其底层还是使用的是Iterator功能。</p>
<h4 id="方式3：使用foreach方式（JDK1-8才有）"><a href="#方式3：使用foreach方式（JDK1-8才有）" class="headerlink" title="方式3：使用foreach方式（JDK1.8才有）"></a>方式3：使用foreach方式（JDK1.8才有）</h4><figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">testMap.<span class="hljs-keyword">for</span><span class="hljs-constructor">Each((<span class="hljs-params">key</span>, <span class="hljs-params">value</span>)</span> -&gt; &#123;<br>    <span class="hljs-module-access"><span class="hljs-module"><span class="hljs-identifier">System</span>.</span></span>out.println(key + <span class="hljs-string">&quot;:&quot;</span> + value);<br>&#125;);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这是一种Lambda表达式。foreach也是一个语法糖，其内部是使用了<strong>方式二</strong>的处理方式，Map的foreach方法实现如下：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="579"></svg>)</p>
<h4 id="方式4：通过key的set集合遍历"><a href="#方式4：通过key的set集合遍历" class="headerlink" title="方式4：通过key的set集合遍历"></a>方式4：通过key的set集合遍历</h4><figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs processing">Iterator&lt;<span class="hljs-keyword">String</span>&gt; keyIterator = testMap.keySet().iterator();<br><span class="hljs-keyword">while</span> (keyIterator.hasNext()) &#123;<br>    <span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span> = keyIterator.next();<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot;:&quot;</span> + testMap.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>));<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这种也是Iterator的方式，不过是通过Set类的iterator方式。</p>
<p>相比<strong>方式1</strong>，这种方式在获取<code>value</code>时，还需要再次通过**<code>testMap.get()</code><strong>的方式，性能相比</strong>方式1<strong>要降低很多。但两者有各自的使用场景，若在Map的遍历中仅使用<code>key</code>，则</strong>方式4<strong>较为适合，若需用到<code>value</code>，推荐使用</strong>方式1**。</p>
<p>从前面的<strong>方式1</strong>和<strong>方式2</strong>可知，方式4还有如下的变体（语法糖的方式）：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">for</span> (<span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span> : testMap.keySet()) &#123;<br>    System.out.<span class="hljs-built_in">println</span>(<span class="hljs-built_in">key</span> + <span class="hljs-string">&quot;:&quot;</span> + testMap.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>));<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>综合以上，在遍历Map时，从性能方面考虑，若需同时使用key和value，推荐使用<strong>方式1</strong>或<strong>方式2</strong>，若单纯只是使用key，推荐使用<strong>方式4</strong>。任何情况下都不推荐使用<strong>方式3</strong>，因为会新增二次查询（通过key再一次在Map中查找value）。</p>
<p>另外，使用<strong>方式1</strong>时，还可以做remove操作，这个下面会讲到。</p>
<h3 id="1-4-2-Iterator的实现原理"><a href="#1-4-2-Iterator的实现原理" class="headerlink" title="1.4.2 Iterator的实现原理"></a>1.4.2 Iterator的实现原理</h3><p>先看一张类/接口的继承关系图：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1030" height="760"></svg>)</p>
<p>Iterator为一个顶层接口，只提供了三个基础方法声明：</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-class"><span class="hljs-keyword">interface</span> <span class="hljs-title">Iterator</span>&lt;<span class="hljs-title">E</span>&gt; </span>&#123;<br>    <br>  <span class="hljs-function"><span class="hljs-keyword">boolean</span> <span class="hljs-title">hasNext</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function">E <span class="hljs-title">next</span><span class="hljs-params">()</span></span>;<br>    <br>    <span class="hljs-function"><span class="hljs-keyword">default</span> <span class="hljs-keyword">void</span> <span class="hljs-title">remove</span><span class="hljs-params">()</span> </span>&#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> UnsupportedOperationException(<span class="hljs-string">&quot;remove&quot;</span>);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>这也是我们使用**<code>Iterator</code><strong>时绕不开的三个方法。 在HashMap中，首先是新增了一个内部抽象类</strong><code>HashIterator</code>**，如下：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="738" height="947"></svg>)</p>
<p>我们以Entry结点的遍历为例（map的key、value的Iterator遍历方式都类似）：</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-built_in">Iterator</span>&lt;Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt;&gt; <span class="hljs-built_in">iterator</span> = testMap.entrySet().<span class="hljs-built_in">iterator</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">iterator</span>.hasNext()) &#123;<br>    Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt; next = <span class="hljs-built_in">iterator</span>.next();<br>    System.out.println(next.getKey() + <span class="hljs-string">&quot;:&quot;</span> + next.getValue());<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>首先，第一行代码，找到**<code>Iterator</code><strong>接口的具体实现类</strong><code>EntryIterator</code>**：</p>
<figure class="highlight scala"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs scala"><span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> <span class="hljs-class"><span class="hljs-keyword">class</span> <span class="hljs-title">EntryIterator</span> <span class="hljs-keyword">extends</span> <span class="hljs-title">HashIterator&lt;Map</span>.<span class="hljs-title">Entry&lt;K</span>,<span class="hljs-title">V&gt;&gt;</span> </span>&#123;<br>    public <span class="hljs-type">Map</span>.<span class="hljs-type">Entry</span>&lt;<span class="hljs-type">K</span>,<span class="hljs-type">V</span>&gt; next() &#123;<br>        <span class="hljs-keyword">return</span> nextEntry();<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>非常简洁有木有？？？就只有一个**<code>next()</code><strong>方法，其正是对</strong><code>Iterator</code><strong>接口的<code>next()</code>方法的实现。方法内部也只有一行，指向了父类的</strong><code>nextEntry()</code><strong>方法，即上面截图中的</strong>HashIterator**类中的<code>nextEntry()</code>方法。</p>
<p>HashMap中的Iterator实现原理也不过如此，就是这么朴实无华，是不是都想动手自己撸一个HashMap的实现了？嗯，你可以的！！！</p>
<h2 id="1-5-fail-fast策略"><a href="#1-5-fail-fast策略" class="headerlink" title="1.5 fail-fast策略"></a>1.5 fail-fast策略</h2><p>和<strong>fail-fast</strong>经常一起出现的还有一个异常类**<code>ConcurrentModificationException</code>**，接下来我们聊下这两者是什么关系，以及为什么搞这么个策略出来。</p>
<p>什么是<strong>fail-fast</strong>？我们可以称它为”快速失效策略”，下面是Wikipedia中的解释：</p>
<blockquote>
<p>In systems design, a fail-fast system is one which immediately reports at its interface any condition that is likely to indicate a failure. Fail-fast systems are usually designed to stop normal operation rather than attempt to continue a possibly flawed process. Such designs often check the system’s state at several points in an operation, so any failures can be detected early. The responsibility of a fail-fast module is detecting errors, then letting the next-highest level of the system handle them.</p>
</blockquote>
<p>大白话翻译过来，就是在系统设计中，当遇到可能会诱导失败的条件时立即上报错误，快速失效系统往往被设计在立即终止正常操作过程，而不是尝试去继续一个可能会存在错误的过程。<br> <strong>再简洁点说</strong>，就是尽可能早的发现问题，立即终止当前执行过程，由更高层级的系统来做处理。</p>
<p>在HashMap中，我们前面提到的**<code>modCount</code><strong>域变量，就是用于实现hashMap中的</strong>fail-fast<strong>。出现这种情况，往往是在非同步的多线程并发操作。<br> 在对Map的做迭代(Iterator)操作时，会将</strong><code>modCount</code><strong>域变量赋值给</strong><code>expectedModCount</code><strong>局部变量。在迭代过程中，用于做内容修改次数的一致性校验。若此时有其他线程或本线程的其他操作对此Map做了内容修改时，那么就会导致</strong>modCount<strong>和</strong>expectedModCount<strong>不一致，立即抛出异常</strong><code>ConcurrentModificationException</code>**。</p>
<p>举个栗子：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">void</span> main(<span class="hljs-keyword">String</span>[] args) &#123;<br>  Map&lt;<span class="hljs-keyword">String</span>, Integer&gt; testMap = <span class="hljs-keyword">new</span> <span class="hljs-keyword">HashMap</span>&lt;&gt;();<br>  testMap.put(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-number">11</span>);<br>  testMap.put(<span class="hljs-string">&quot;s2&quot;</span>, <span class="hljs-number">22</span>);<br>  testMap.put(<span class="hljs-string">&quot;s3&quot;</span>, <span class="hljs-number">33</span>);<br><br><br>  <span class="hljs-keyword">for</span> (Map.Entry&lt;<span class="hljs-keyword">String</span>, Integer&gt; entry : testMap.entrySet()) &#123;<br>      <span class="hljs-keyword">String</span> <span class="hljs-built_in">key</span> = entry.getKey();<br>      <span class="hljs-keyword">if</span> (<span class="hljs-string">&quot;s1&quot;</span>.equals(<span class="hljs-built_in">key</span>)) &#123;<br>          testMap.remove(<span class="hljs-built_in">key</span>);<br>      &#125;<br>  &#125;<br>&#125;<br><br><br>---- output ---<br>Exception in thread <span class="hljs-string">&quot;main&quot;</span> java.util.ConcurrentModificationException<br>  at java.util.<span class="hljs-keyword">HashMap</span>$HashIterator.nextNode(<span class="hljs-keyword">HashMap</span>.java:<span class="hljs-number">1437</span>)<br>  at java.util.<span class="hljs-keyword">HashMap</span>$EntryIterator.next(<span class="hljs-keyword">HashMap</span>.java:<span class="hljs-number">1471</span>)<br>  at java.util.<span class="hljs-keyword">HashMap</span>$EntryIterator.next(<span class="hljs-keyword">HashMap</span>.java:<span class="hljs-number">1469</span>)<br>    ...<br>复制代码<br></code></pre></td></tr></table></figure>

<p>正确的删除Map元素的姿势：只有一个，Iteator的**<code>remove()</code>**方法。</p>
<figure class="highlight php"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs php"><span class="hljs-comment">// 方式三</span><br><span class="hljs-built_in">Iterator</span>&lt;Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt;&gt; <span class="hljs-built_in">iterator</span> = testMap.entrySet().<span class="hljs-built_in">iterator</span>();<br><span class="hljs-keyword">while</span> (<span class="hljs-built_in">iterator</span>.hasNext()) &#123;<br>    Entry&lt;<span class="hljs-keyword">String</span>, <span class="hljs-keyword">Integer</span>&gt; next = <span class="hljs-built_in">iterator</span>.next();<br>    System.out.println(next.getKey() + <span class="hljs-string">&quot;:&quot;</span> + next.getValue());<br>    <span class="hljs-keyword">if</span> (next.getKey().equals(<span class="hljs-string">&quot;s2&quot;</span>)) &#123;<br>        <span class="hljs-built_in">iterator</span>.remove();<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>但也要注意一点，能安全删除，并不代表就是多线程安全的，在多线程并发执行时，若都执行上面的操作，因未设置为同步方法，也可能导致**<code>modCount</code><strong>与</strong><code>expectedModCount</code><strong>不一致，从而抛异常</strong><code>ConcurrentModificationException</code>**。 线程不安全的体现和规避方式，后续章节会详细提及。</p>
<h1 id="二、JDK8中的HashMap底层实现"><a href="#二、JDK8中的HashMap底层实现" class="headerlink" title="二、JDK8中的HashMap底层实现"></a>二、JDK8中的HashMap底层实现</h1><p>前面我们已经详细剖析了HashMap在JDK7中的实现，不知大家有没有发现其中可以优化的地方？比如哈希表中因为hash碰撞而产生的链表结构，如果数据量很大，那么产生碰撞的几率很增加，这带来的后果就是链表长度也一直在增加，对于查询来说，性能会越来越低。如何提升查询性能，成了JDK8中的HashMap要解决的问题。</p>
<p>因此，相比于JDK7，HashMap在JDK8中做链表结构做了优化（但仍然线程不安全），在一定条件下将链表转为红黑树，提升查询效率。</p>
<p>JDK8中的HashMap其底层存储结构如下：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="948" height="816"></svg>)</p>
<p>相比于JDK7，JDK8中的HashMap会将较长的链表转为红黑树，这也是与JDK7的核心差异。下面先看下**<code>put()</code>**方法的实现。</p>
<h2 id="2-1-put-操作"><a href="#2-1-put-操作" class="headerlink" title="2.1 put()操作"></a>2.1 put()操作</h2><p>在进一步分析**<code>put()</code><strong>操作前，先说明一下：除了底层存储结构有调整，链表结点的定义也由</strong><code>Entry</code><strong>类转为了</strong><code>Node</code>**类，但内核没有变化，不影响理解。</p>
<p>先上源代码：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="822" height="926"></svg>)</p>
<p>是不是很长很复杂？其实不难，只要记住上面的底层存储结构图，代码就很容易看懂。还是一样的存储套路，先根据key确定在哈希table中的下标，找到对应的bucket，遍历链表（或红黑树），做插入操作。在JDK7中，新增结点是使用<strong>头插法</strong>，但在JDK8中，在链表使用<strong>尾插法</strong>，将待新增结点追加到链表末尾。</p>
<p>为方便理解，将上面的代码转为了下面的流程图：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="1254"></svg>)</p>
<p><strong>步骤①</strong>：若哈希table为null，或长度为0，则做一次扩容操作； <strong>步骤②</strong>：根据index找到目标bucket后，若当前bucket上没有结点，那么直接新增一个结点，赋值给该bucket； <strong>步骤③</strong>：若当前bucket上有链表，且头结点就匹配，那么直接做替换即可； <strong>步骤④</strong>：若当前bucket上的是树结构，则转为红黑树的插入操作； <strong>步骤⑤</strong>：若步骤①、②、③、④都不成立，则对链表做遍历操作。   a) 若链表中有结点匹配，则做value替换；   b）若没有结点匹配，则在链表末尾追加。同时，执行以下操作：    i) 若链表长度大于<code>TREEIFY_THRESHOLD</code>，则执行红黑树转换操作；    ii) 若<strong>条件i)</strong> 不成立，则执行扩容resize()操作。 以上5步都执行完后，再看当前Map中存储的k-v对的数量是否超出了**<code>threshold</code>**，若超出，还需再次扩容。</p>
<p>红黑树的转换操作如下：</p>
<figure class="highlight nix"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs nix"><span class="hljs-comment">/**</span><br><span class="hljs-comment"> * Replaces all linked nodes in bin at index for given hash unless</span><br><span class="hljs-comment"> * table is too small, in which case resizes instead.</span><br><span class="hljs-comment"> */</span><br>final void treeifyBin(Node&lt;K,V&gt;[] tab, int hash) &#123;<br>    int n, index; Node&lt;K,V&gt; e;<br>    // 若表为空，或表长度小于MIN_TREEIFY_CAPACITY，也不做转换，直接做扩容处理。<br>    <span class="hljs-keyword">if</span> (<span class="hljs-attr">tab</span> == <span class="hljs-literal">null</span> || (<span class="hljs-attr">n</span> = tab.length) &lt; MIN_TREEIFY_CAPACITY)<br>        resize();<br>    <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> ((<span class="hljs-attr">e</span> = tab[<span class="hljs-attr">index</span> = (n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-literal">null</span>) &#123;<br>        TreeNode&lt;K,V&gt; <span class="hljs-attr">hd</span> = <span class="hljs-literal">null</span>, <span class="hljs-attr">tl</span> = <span class="hljs-literal">null</span>;<br>        do &#123;<br>            TreeNode&lt;K,V&gt; <span class="hljs-attr">p</span> = replacementTreeNode(e, <span class="hljs-literal">null</span>);<br>            <span class="hljs-keyword">if</span> (<span class="hljs-attr">tl</span> == <span class="hljs-literal">null</span>)<br>                <span class="hljs-attr">hd</span> = p;<br>            <span class="hljs-keyword">else</span> &#123;<br>                p.<span class="hljs-attr">prev</span> = tl;<br>                tl.<span class="hljs-attr">next</span> = p;<br>            &#125;<br>            <span class="hljs-attr">tl</span> = p;<br>        &#125; while ((<span class="hljs-attr">e</span> = e.next) != <span class="hljs-literal">null</span>);<br>        <span class="hljs-keyword">if</span> ((tab[index] = hd) != <span class="hljs-literal">null</span>)<br>            hd.treeify(tab);<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="2-2-扩容操作"><a href="#2-2-扩容操作" class="headerlink" title="2.2 扩容操作"></a>2.2 扩容操作</h2><p>什么场景下会触发扩容？<br> <strong>场景1</strong>：哈希table为null或长度为0；<br> <strong>场景2</strong>：Map中存储的k-v对数量超过了阈值**<code>threshold</code>**；<br> <strong>场景3</strong>：链表中的长度超过了<code>TREEIFY_THRESHOLD</code>，但表长度却小于<code>MIN_TREEIFY_CAPACITY</code>。</p>
<p>一般的扩容分为2步，<strong>第1步</strong>是对哈希表长度的扩展（2倍），<strong>第2步</strong>是将旧table中的数据搬到新table上。<br> 那么，在JDK8中，HashMap是如何扩容的呢？</p>
<p>上源代码片段：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br></pre></td><td class="code"><pre><code class="hljs haxe">...<br><span class="hljs-comment">// 前面已经做了第1步的长度拓展，我们主要分析第2步的操作：如何迁移数据</span><br>table = <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>;<br><span class="hljs-keyword">if</span> (oldTab != <span class="hljs-literal">null</span>) &#123;<br>    <span class="hljs-comment">// 循环遍历哈希table的每个不为null的bucket</span><br>    <span class="hljs-comment">// 注意，这里是&quot;++j&quot;，略过了oldTab[0]的处理</span><br>    <span class="hljs-keyword">for</span> (int j = <span class="hljs-number">0</span>; j &lt; oldCap; ++j) &#123;<br>        Node&lt;K,V&gt; e;<br>        <span class="hljs-keyword">if</span> ((e = oldTab[j]) != <span class="hljs-literal">null</span>) &#123;<br>            oldTab[j] = <span class="hljs-literal">null</span>;<br>            <span class="hljs-comment">// 若只有一个结点，则原地存储</span><br>            <span class="hljs-keyword">if</span> (e.next == <span class="hljs-literal">null</span>)<br>                <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[e.hash &amp; (<span class="hljs-keyword">new</span><span class="hljs-type">Cap</span> - <span class="hljs-number">1</span>)] = e;<br>            <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (e instanceof TreeNode)<br>                ((TreeNode&lt;K,V&gt;)e).split(<span class="hljs-built_in">this</span>, <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>, j, oldCap);<br>            <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// preserve order</span><br>                <span class="hljs-comment">// &quot;lo&quot;前缀的代表要在原bucket上存储，&quot;hi&quot;前缀的代表要在新的bucket上存储</span><br>                <span class="hljs-comment">// loHead代表是链表的头结点，loTail代表链表的尾结点</span><br>                Node&lt;K,V&gt; loHead = <span class="hljs-literal">null</span>, loTail = <span class="hljs-literal">null</span>;<br>                Node&lt;K,V&gt; hiHead = <span class="hljs-literal">null</span>, hiTail = <span class="hljs-literal">null</span>;<br>                Node&lt;K,V&gt; next;<br>                <span class="hljs-keyword">do</span> &#123;<br>                    next = e.next;<br>                    <span class="hljs-comment">// 以oldCap=8为例，</span><br>                    <span class="hljs-comment">//   0001 1000  e.hash=24</span><br>                    <span class="hljs-comment">// &amp; 0000 1000  oldCap=8</span><br>                    <span class="hljs-comment">// = 0000 1000  --&gt; 不为0，需要迁移</span><br>                    <span class="hljs-comment">// 这种规律可发现，[oldCap, (2*oldCap-1)]之间的数据，</span><br>                    <span class="hljs-comment">// 以及在此基础上加n*2*oldCap的数据，都需要做迁移，剩余的则不用迁移</span><br>                    <span class="hljs-keyword">if</span> ((e.hash &amp; oldCap) == <span class="hljs-number">0</span>) &#123;<br>                        <span class="hljs-comment">// 这种是有序插入，即依次将原链表的结点追加到当前链表的末尾</span><br>                        <span class="hljs-keyword">if</span> (loTail == <span class="hljs-literal">null</span>)<br>                            loHead = e;<br>                        <span class="hljs-keyword">else</span><br>                            loTail.next = e;<br>                        loTail = e;<br>                    &#125;<br>                    <span class="hljs-keyword">else</span> &#123;<br>                        <span class="hljs-keyword">if</span> (hiTail == <span class="hljs-literal">null</span>)<br>                            hiHead = e;<br>                        <span class="hljs-keyword">else</span><br>                            hiTail.next = e;<br>                        hiTail = e;<br>                    &#125;<br>                &#125; <span class="hljs-keyword">while</span> ((e = next) != <span class="hljs-literal">null</span>);<br>                <span class="hljs-keyword">if</span> (loTail != <span class="hljs-literal">null</span>) &#123;<br>                    loTail.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j] = loHead;<br>                &#125;<br>                <span class="hljs-keyword">if</span> (hiTail != <span class="hljs-literal">null</span>) &#123;<br>                    hiTail.next = <span class="hljs-literal">null</span>;<br>                    <span class="hljs-comment">// 需要搬迁的结点，新下标为从当前下标往前挪oldCap个距离。</span><br>                    <span class="hljs-keyword">new</span><span class="hljs-type">Tab</span>[j + oldCap] = hiHead;<br>                &#125;<br>            &#125;<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="2-3-get-操作"><a href="#2-3-get-操作" class="headerlink" title="2.3 get()操作"></a>2.3 get()操作</h2><p>了解了上面的put()操作，get()操作就比较简单了。</p>
<figure class="highlight q"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs q">public V <span class="hljs-built_in">get</span>(Object <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt; e;<br>    return (e = getNode(hash(<span class="hljs-built_in">key</span>), <span class="hljs-built_in">key</span>)) == <span class="hljs-built_in">null</span> ? <span class="hljs-built_in">null</span> : e.<span class="hljs-built_in">value</span>;<br>&#125;<br><br><br>final Node&lt;K,V&gt; getNode(<span class="hljs-type">int</span> hash, Object <span class="hljs-built_in">key</span>) &#123;<br>    Node&lt;K,V&gt;[] tab; Node&lt;K,V&gt; <span class="hljs-built_in">first</span>, e; <span class="hljs-type">int</span> n; K k;<br>    if ((tab = table) != <span class="hljs-built_in">null</span> &amp;&amp; (n = tab.length) &gt; <span class="hljs-number">0</span> &amp;&amp;<br>        (<span class="hljs-built_in">first</span> = tab[(n - <span class="hljs-number">1</span>) &amp; hash]) != <span class="hljs-built_in">null</span>) &#123;<br>        if (<span class="hljs-built_in">first</span>.hash == hash &amp;&amp; <span class="hljs-comment">// always check first node</span><br>            ((k = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>            return <span class="hljs-built_in">first</span>;<br>        if ((e = <span class="hljs-built_in">first</span>.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>) &#123;<br>            if (<span class="hljs-built_in">first</span> instanceof TreeNode)<br>                return ((TreeNode&lt;K,V&gt;)<span class="hljs-built_in">first</span>).getTreeNode(hash, <span class="hljs-built_in">key</span>);<br>            <span class="hljs-keyword">do</span> &#123;<br>                if (e.hash == hash &amp;&amp;<br>                    ((k = e.<span class="hljs-built_in">key</span>) == <span class="hljs-built_in">key</span> || (<span class="hljs-built_in">key</span> != <span class="hljs-built_in">null</span> &amp;&amp; <span class="hljs-built_in">key</span>.equals(k))))<br>                    return e;<br>            &#125; <span class="hljs-keyword">while</span> ((e = e.<span class="hljs-built_in">next</span>) != <span class="hljs-built_in">null</span>);<br>        &#125;<br>    &#125;<br>    return <span class="hljs-built_in">null</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>先根据key计算hash值，进一步计算得到哈希table的目标index，若此bucket上为红黑树，则再红黑树上查找，若不是红黑树，遍历链表。</p>
<h1 id="三、HashMap、HashTable是什么关系？"><a href="#三、HashMap、HashTable是什么关系？" class="headerlink" title="三、HashMap、HashTable是什么关系？"></a>三、HashMap、HashTable是什么关系？</h1><p>再把文章开头的这张图放出来，温习一下：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="979"></svg>)</p>
<h2 id="3-1-共同点与异同点"><a href="#3-1-共同点与异同点" class="headerlink" title="3.1 共同点与异同点"></a>3.1 共同点与异同点</h2><p><strong>共同点</strong>：</p>
<ul>
<li>底层都是使用哈希表 + 链表的实现方式。</li>
</ul>
<p><strong>区别</strong>：</p>
<ul>
<li>从层级结构上看，HashMap、HashTable有一个共用的**<code>Map</code><strong>接口。另外，HashTable还单独继承了一个抽象类</strong><code>Dictionary</code>**；</li>
<li>HashTable诞生自JDK1.0，HashMap从JDK1.2之后才有；</li>
<li>HashTable线程安全，HashMap线程不安全；</li>
<li>初始值和扩容方式不同。HashTable的初始值为11，扩容为原大小的<code>2*d+1</code>。容量大小都采用奇数且为素数，且采用取模法，这种方式散列更均匀。但有个缺点就是对素数取模的性能较低（涉及到除法运算），而HashTable的长度都是2的次幂，设计就较为巧妙，前面章节也提到过，这种方式的取模都是直接做位运算，性能较好。</li>
<li>HashMap的key、value都可为null，且value可多次为null，key多次为null时会覆盖。当HashTable的key、value都不可为null，否则直接NPE(NullPointException)。</li>
</ul>
<p><strong>示例：</strong></p>
<figure class="highlight typescript"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><code class="hljs typescript"><span class="hljs-keyword">public</span> <span class="hljs-keyword">static</span> <span class="hljs-built_in">void</span> <span class="hljs-function"><span class="hljs-title">main</span>(<span class="hljs-params"><span class="hljs-built_in">String</span>[] args</span>)</span> &#123;<br>  <span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, Integer&gt; testTable = <span class="hljs-keyword">new</span> Hashtable&lt;&gt;();<br>    testTable.put(<span class="hljs-literal">null</span>, <span class="hljs-number">23</span>);  <span class="hljs-comment">// 抛NPE</span><br>    testTable.put(<span class="hljs-string">&quot;s1&quot;</span>, <span class="hljs-literal">null</span>); <span class="hljs-comment">// 抛NPE</span><br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>看下**<code>put()</code>**方法的源码：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-keyword">public</span> <span class="hljs-keyword">synchronized</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;<br>    <span class="hljs-comment">// Make sure the value is not null</span><br>    <span class="hljs-keyword">if</span> (value == <span class="hljs-keyword">null</span>) &#123;<br>        <span class="hljs-keyword">throw</span> <span class="hljs-keyword">new</span> NullPointerException();<br>    &#125;<br><br><br>    <span class="hljs-comment">// Makes sure the key is not already in the hashtable.</span><br>    Entry&lt;?,?&gt; tab[] = table;<br>    <span class="hljs-built_in">int</span> hash = <span class="hljs-built_in">key</span>.hashCode();<br>    <span class="hljs-built_in">int</span> index = (hash &amp; <span class="hljs-number">0x7FFFFFFF</span>) % tab.length;<br>    @SuppressWarnings(<span class="hljs-string">&quot;unchecked&quot;</span>)<br>    Entry&lt;K,V&gt; entry = (Entry&lt;K,V&gt;)tab[index];<br>    <span class="hljs-keyword">for</span>(; entry != <span class="hljs-keyword">null</span> ; entry = entry.next) &#123;<br>        <span class="hljs-keyword">if</span> ((entry.hash == hash) &amp;&amp; entry.<span class="hljs-built_in">key</span>.equals(<span class="hljs-built_in">key</span>)) &#123;<br>            V old = entry.value;<br>            entry.value = value;<br>            <span class="hljs-keyword">return</span> old;<br>        &#125;<br>    &#125;<br><br><br>    addEntry(hash, <span class="hljs-built_in">key</span>, value, index);<br>    <span class="hljs-keyword">return</span> <span class="hljs-keyword">null</span>;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>源码中不允许value为null，若为null则直接抛NPE。<br> 对于key为null时，源码第9行：<code>int hash = key.hashCode();</code> 未做判空操作，也会外抛NPE。</p>
<p>另外，我们现在看到的抽象类<code>Dictionary</code>，是一个已经废弃的类，源码注释中有如下说明：</p>
<figure class="highlight gradle"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs gradle">&lt;strong&gt;NOTE: <span class="hljs-keyword">This</span> <span class="hljs-keyword">class</span> is obsolete.  <span class="hljs-keyword">New</span> implementations should<br>implement the Map <span class="hljs-keyword">interface</span>, rather than extending <span class="hljs-keyword">this</span> <span class="hljs-keyword">class</span>.&lt;/strong&gt;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="3-2-HashMap的线程安全"><a href="#3-2-HashMap的线程安全" class="headerlink" title="3.2 HashMap的线程安全"></a>3.2 HashMap的线程安全</h2><p>能保证线程线程安全的方式有多个，比如添加<code>synchronized</code>关键字，或者使用<code>lock</code>机制。两者的差异不在此展开，后续会写有关线程安全的文章，到时再详细说明。而HashTable使用了前者，即<code>synchronized</code>关键字。</p>
<p>put操作、get操作、remove操作、equals操作，都使用了<code>synchronized</code>关键字修饰。</p>
<p>这么做是保证了HashTable对象的线程安全特性，但同样也带来了问题，突出问题就是效率低下。为何会说它效率低下呢？<br> 因为按synchronized的特性，对于多线程共享的临界资源，同一时刻只能有一个线程在占用，其他线程必须原地等待，为方便理解，大家不妨想下计时用的沙漏，中间最细的瓶颈处阻挡了上方细沙的下落，同样的道理，当有大量线程要执行<code>get()</code>操作时，也存在此类问题，大量线程必须排队一个个处理。</p>
<p>这时可能会有人说，既然<code>get()</code>方法只是获取数据，并没有修改Map的结构和数据，不加不就行了吗？不好意思，不加也不行，别的方法都加，就你不加，会有一种场景，那就是A线程在做put或remove操作时，B线程、C线程此时都可以同时执行get操作，可能哈希table已经被A线程改变了，也会带来问题，因此不加也不行。</p>
<p>现在好了，HashMap线程不安全，HashTable虽然线程安全，但性能差，那怎么破？使用<code>ConcurrentHashMap</code>类吧，既线程安全，还操作高效，谁用谁说好。莫急，下面章节会详细解释<code>ConcurrentHashMap</code>类。</p>
<h1 id="四、HashMap线程不安全在哪？"><a href="#四、HashMap线程不安全在哪？" class="headerlink" title="四、HashMap线程不安全在哪？"></a>四、HashMap线程不安全在哪？</h1><p>本章节主要探讨下HashMap的线程不安全会带来哪些方面的问题。</p>
<h2 id="4-1-数据覆盖问题"><a href="#4-1-数据覆盖问题" class="headerlink" title="4.1 数据覆盖问题"></a>4.1 数据覆盖问题</h2><p>两个线程执行<code>put()</code>操作时，可能导致数据覆盖。JDK7版本和JDK8版本的都存在此问题，这里以JDK7为例。</p>
<p>假设A、B两个线程同时执行<code>put()</code>操作，且两个key都指向同一个buekct，那么此时两个结点，都会做头插法。 先看这里的代码实现：</p>
<figure class="highlight reasonml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs reasonml">public V put(K key, V value) &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>add<span class="hljs-constructor">Entry(<span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>, <span class="hljs-params">i</span>)</span>;<br>&#125;<br><br><br>void add<span class="hljs-constructor">Entry(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">int</span> <span class="hljs-params">bucketIndex</span>)</span> &#123;<span class="hljs-operator"></span><br><span class="hljs-operator">    ...</span><br><span class="hljs-operator">    </span>create<span class="hljs-constructor">Entry(<span class="hljs-params">hash</span>, <span class="hljs-params">key</span>, <span class="hljs-params">value</span>, <span class="hljs-params">bucketIndex</span>)</span>;<br>&#125;<br><br><br>void create<span class="hljs-constructor">Entry(<span class="hljs-params">int</span> <span class="hljs-params">hash</span>, K <span class="hljs-params">key</span>, V <span class="hljs-params">value</span>, <span class="hljs-params">int</span> <span class="hljs-params">bucketIndex</span>)</span> &#123;<br>    Entry&lt;K,V&gt; e = table<span class="hljs-literal">[<span class="hljs-identifier">bucketIndex</span>]</span>;<br>    table<span class="hljs-literal">[<span class="hljs-identifier">bucketIndex</span>]</span> = <span class="hljs-keyword">new</span> Entry&lt;&gt;(hash, key, value, e);<br>    size++;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>看下最后的<code>createEntry()</code>方法，首先获取到了bucket上的头结点，然后再将新结点作为bucket的头部，并指向旧的头结点，完成一次头插法的操作。<br> 当线程A和线程B都获取到了bucket的头结点后，若此时线程A的时间片用完，线程B将其新数据完成了头插法操作，此时轮到线程A操作，但这时线程A所据有的旧头结点已经过时了（并未包含线程B刚插入的新结点），线程A再做头插法操作，就会抹掉B刚刚新增的结点，导致数据丢失。</p>
<p>其实不光是<code>put()</code>操作，删除操作、修改操作，同样都会有覆盖问题。</p>
<h2 id="4-2-扩容时导致死循环"><a href="#4-2-扩容时导致死循环" class="headerlink" title="4.2 扩容时导致死循环"></a>4.2 扩容时导致死循环</h2><p>这是最常遇到的情况，也是面试经常被问及的考题。但说实话，这个多线程环境下导致的死循环问题，并不是那么容易解释清楚，因为这里已经深入到了扩容的细节。这里尽可能简单的描述死循环的产生过程。</p>
<p>另外，只有JDK7及以前的版本会存在死循环现象，在JDK8中，resize()方式已经做了调整，使用两队链表，且都是使用的尾插法，及时多线程下，也顶多是从头结点再做一次尾插法，不会造成死循环。而JDK7能造成死循环，就是因为resize()时使用了头插法，将原本的顺序做了反转，才留下了死循环的机会。</p>
<p>在进一步说明死循环的过程前，我们先看下JDK7中的扩容代码片段：</p>
<figure class="highlight haxe"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs haxe">void transfer(Entry[] <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>, boolean rehash) &#123;<br>    int <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span> = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>.length;<br>    <span class="hljs-keyword">for</span> (Entry&lt;K,V&gt; e : <span class="hljs-type">table</span>) &#123;<br>        <span class="hljs-keyword">while</span>(<span class="hljs-literal">null</span> != e) &#123;<br>            Entry&lt;K,V&gt; next = e.next;<br>            <span class="hljs-keyword">if</span> (rehash) &#123;<br>                e.hash = <span class="hljs-literal">null</span> == e.key ? <span class="hljs-number">0</span> : <span class="hljs-type">hash</span>(e.key);<br>            &#125;<br>            int i = indexFor(e.hash, <span class="hljs-keyword">new</span><span class="hljs-type">Capacity</span>);<br>            e.next = <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i];<br>            <span class="hljs-keyword">new</span><span class="hljs-type">Table</span>[i] = e;<br>            e = next;<br>        &#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其实就是简单的链表反转，再进一步简化的话，分为当前结点<code>e</code>，以及下一个结点<code>e.next</code>。我们以链表<code>a-&gt;b-&gt;c-&gt;null</code>为例，两个线程A和B，分别做扩容操作。</p>
<p><strong>原表</strong>：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="768" height="638"></svg>)</p>
<p>线程A和B各自新增了一个新的哈希table，在线程A已做完扩容操作后，线程B才开始扩容。此时对于线程B来说，当前结点<code>e</code>指向a结点，下一个结点<code>e.next</code>仍然指向b结点（此时在线程A的链表中，已经是<code>c-&gt;b-&gt;a</code>的顺序）。按照头插法，哈希表的bucket指向a结点，此时a结点成为线程B中链表的头结点，如下图所示：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1068" height="1280"></svg>)</p>
<p>a结点成为线程B中链表的头结点后，下一个结点<code>e.next</code>为b结点。既然下一个结点<code>e.next</code>不为null，那么当前结点<code>e</code>就变成了b结点，下一个结点<code>e.next</code>变为a结点。继续执行头插法，将b变为链表的头结点，同时next指针指向旧的头节点a，如下图：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="706"></svg>)</p>
<p>此时，下一个结点<code>e.next</code>为a节点，不为null，继续头插法。指针后移，那么当前结点<code>e</code>就成为了a结点，下一个结点为null。将a结点作为线程B链表中的头结点，并将next指针指向原来的旧头结点b，如下图所示：</p>
<p>![img](data:image/svg+xml;utf8,<?xml version="1.0"?><svg xmlns="http://www.w3.org/2000/svg" version="1.1" width="1280" height="706"></svg>)</p>
<p>此时，已形成环链表。同时下一个结点<code>e.next</code>为null，流程结束。</p>
<h2 id="4-3-小结"><a href="#4-3-小结" class="headerlink" title="4.3 小结"></a>4.3 小结</h2><p>多线程环境下使用HashMap，会引起各类问题，上面仅为不安全问题的两个典型示例，具体问题无法一一列举，但大体会分为以下三类：</p>
<ul>
<li>死循环</li>
<li>数据重复</li>
<li>数据丢失（覆盖）</li>
</ul>
<p>在JDK1.5之前，多线程环境往往使用HashTable，但在JDK1.5及以后的版本中，在并发包中引入了专门用于多线程环境的**<code>ConcurrentHashMap</code>**类，采用分段锁实现了线程安全，相比HashTable有更高的性能，推荐使用。</p>
<h1 id="五、如何规避HashMap的线程不安全？"><a href="#五、如何规避HashMap的线程不安全？" class="headerlink" title="五、如何规避HashMap的线程不安全？"></a>五、如何规避HashMap的线程不安全？</h1><p>前面提到了HashMap在多线程环境下的各类不安全问题，那么有哪些方式可以转成线程安全的呢？</p>
<h2 id="5-1-将Map转为包装类"><a href="#5-1-将Map转为包装类" class="headerlink" title="5.1 将Map转为包装类"></a>5.1 将Map转为包装类</h2><p>如何转？使用**<code>Collections.SynchronizedMap()</code>**方法，示例代码：</p>
<figure class="highlight lasso"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs lasso"><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; testMap = <span class="hljs-literal">new</span> HashMap&lt;&gt;();<br><span class="hljs-params">...</span><br><span class="hljs-comment">// 转为线程安全的map</span><br><span class="hljs-built_in">Map</span>&lt;<span class="hljs-built_in">String</span>, <span class="hljs-built_in">Integer</span>&gt; <span class="hljs-built_in">map</span> = Collections.synchronizedMap(testMap);<br>复制代码<br></code></pre></td></tr></table></figure>

<p>其内部实现也很简单，等同于HashTable，只是对当前传入的map对象，新增对象锁（synchronized）：</p>
<figure class="highlight processing"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><code class="hljs processing"><span class="hljs-comment">// 源码来自Collections类</span><br><br><br><span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> class SynchronizedMap&lt;K,V&gt; implements Map&lt;K,V&gt;, Serializable &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">static</span> <span class="hljs-keyword">final</span> <span class="hljs-keyword">long</span> serialVersionUID = <span class="hljs-number">1978198479659022715</span>L;<br><br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">final</span> Map&lt;K,V&gt; m;     <span class="hljs-comment">// Backing Map</span><br>    <span class="hljs-keyword">final</span> <span class="hljs-keyword">Object</span>      mutex;        <span class="hljs-comment">// Object on which to synchronize</span><br><br><br>    SynchronizedMap(Map&lt;K,V&gt; m) &#123;<br>        <span class="hljs-keyword">this</span>.m = Objects.requireNonNull(m);<br>        mutex = <span class="hljs-keyword">this</span>;<br>    &#125;<br><br><br>    SynchronizedMap(Map&lt;K,V&gt; m, <span class="hljs-keyword">Object</span> mutex) &#123;<br>        <span class="hljs-keyword">this</span>.m = m;<br>        <span class="hljs-keyword">this</span>.mutex = mutex;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">int</span> <span class="hljs-built_in">size</span>() &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.<span class="hljs-built_in">size</span>();&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> isEmpty() &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.isEmpty();&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> containsKey(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.containsKey(<span class="hljs-built_in">key</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-built_in">boolean</span> containsValue(<span class="hljs-keyword">Object</span> value) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.containsValue(value);&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> V <span class="hljs-built_in">get</span>(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.<span class="hljs-built_in">get</span>(<span class="hljs-built_in">key</span>);&#125;<br>    &#125;<br><br><br>    <span class="hljs-keyword">public</span> V put(K <span class="hljs-built_in">key</span>, V value) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.put(<span class="hljs-built_in">key</span>, value);&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> V remove(<span class="hljs-keyword">Object</span> <span class="hljs-built_in">key</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;<span class="hljs-keyword">return</span> m.remove(<span class="hljs-built_in">key</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> putAll(Map&lt;? extends K, ? extends V&gt; <span class="hljs-built_in">map</span>) &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;m.putAll(<span class="hljs-built_in">map</span>);&#125;<br>    &#125;<br>    <span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-built_in">clear</span>() &#123;<br>        <span class="hljs-keyword">synchronized</span> (mutex) &#123;m.<span class="hljs-built_in">clear</span>();&#125;<br>    &#125;<br>&#125;<br>复制代码<br></code></pre></td></tr></table></figure>

<h2 id="5-2-使用ConcurrentHashMap"><a href="#5-2-使用ConcurrentHashMap" class="headerlink" title="5.2 使用ConcurrentHashMap"></a>5.2 使用ConcurrentHashMap</h2><p>既然<strong>HashMap</strong>类是线程不安全的，那就不妨找个线程安全的替代品——**<code>ConcurrentHashMap</code>**类。</p>
<p>使用示例：</p>
<figure class="highlight arduino"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs arduino">Map&lt;<span class="hljs-keyword">String</span>, Integer&gt; susuMap = <span class="hljs-keyword">new</span> ConcurrentHashMap&lt;&gt;();<br>susuMap.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;susu1&quot;</span>, <span class="hljs-number">111</span>);<br>susuMap.<span class="hljs-built_in">put</span>(<span class="hljs-string">&quot;susu2&quot;</span>, <span class="hljs-number">222</span>);<br>System.out.<span class="hljs-built_in">println</span>(susuMap.<span class="hljs-built_in">get</span>(<span class="hljs-string">&quot;susu1&quot;</span>));<br>复制代码<br></code></pre></td></tr></table></figure>

<p>在使用习惯上完全兼容了HashMap的使用。</p>
<p>JDK1.5版本引入，位于并发包<code>java.util.concurrent</code>下。</p>
<p>在JDK7版本及以前，**<code>ConcurrentHashMap</code>**类使用了分段锁的技术（segment + Lock），但在jdk8中，也做了较大改动，使用回了synchronized修饰符。 具体差别，在以后的文章中再详细介绍。</p>
<p>作者：码不停蹄的小鼠松<br>链接：<a target="_blank" rel="noopener" href="https://juejin.im/post/5de85e05f265da33b50727f6">https://juejin.im/post/5de85e05f265da33b50727f6</a><br>来源：掘金<br>著作权归作者所有。商业转载请联系作者获得授权，非商业转载请注明出处。</p>
      </section>
      <section class="extra">
        
          <ul class="copyright">
  
    <li><strong>本文作者：</strong>John Doe</li>
    <li><strong>本文链接：</strong><a href="http://yoursite.com/2020/07/12/%E4%BD%A0%E7%9C%9F%E6%AD%A3%E4%BA%86%E8%A7%A3HashMap%E5%90%97/index.html" title="http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;07&#x2F;12&#x2F;%E4%BD%A0%E7%9C%9F%E6%AD%A3%E4%BA%86%E8%A7%A3HashMap%E5%90%97&#x2F;index.html">http:&#x2F;&#x2F;yoursite.com&#x2F;2020&#x2F;07&#x2F;12&#x2F;%E4%BD%A0%E7%9C%9F%E6%AD%A3%E4%BA%86%E8%A7%A3HashMap%E5%90%97&#x2F;index.html</a></li>
    <li><strong>版权声明：</strong>本博客所有文章均采用 <a href="https://creativecommons.org/licenses/by-nc-sa/4.0/deed.zh" title="BY-NC-SA" target="_blank" rel="noopener">BY-NC-SA</a> 许可协议，转载请注明出处！</li>
  
</ul>
        
        
          <section class="donate">
  <div id="qrcode-donate">
    <img src="https://pic.izhaoo.com/alipay.jpg">
  </div>
  <div class="icon">
    <a href="javascript:;" id="alipay"><i class="iconfont iconalipay"></i></a>
    <a href="javascript:;" id="wechat"><i class="iconfont iconwechat-fill"></i></a>
  </div>
</section>
        
        
  <ul class="tag-list" itemprop="keywords"><li class="tag-list-item"><a class="tag-list-link" href="/tags/%E6%95%B0%E7%BB%84/" rel="tag">数组</a></li></ul> 

        
  <nav class="nav">
    <a href="/2020/07/19/01mysql/01Mysql%E7%B4%A2%E5%BC%95%E7%AE%80%E4%BB%8B/"><i class="iconfont iconleft"></i>一、Mysql-索引简介</a>
    <a href="/2020/07/12/linux%E5%91%BD%E4%BB%A4/">Linux高级<i class="iconfont iconright"></i></a>
  </nav>

      </section>
      
    </section>
  </div>
</article></div>
      <div class="col-xl-3">
        
          
  <aside class="toc-wrap">
    <h3 class="toc-title">文章目录：</h3>
    <ol class="toc"><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%80%E3%80%81JDK7%E4%B8%AD%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">一、JDK7中的HashMap底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#1-1-%E5%9F%BA%E7%A1%80%E7%9F%A5%E8%AF%86"><span class="toc-text">1.1 基础知识</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-2-put-%E6%96%B9%E6%B3%95"><span class="toc-text">1.2 put()方法</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-1-%E7%89%B9%E6%AE%8Akey%E5%80%BC%E5%A4%84%E7%90%86"><span class="toc-text">1.2.1 特殊key值处理</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-2-%E6%89%A9%E5%AE%B9"><span class="toc-text">1.2.2 扩容</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-3-%E5%A6%82%E4%BD%95%E8%AE%A1%E7%AE%97bucket%E4%B8%8B%E6%A0%87%EF%BC%9F"><span class="toc-text">1.2.3 如何计算bucket下标？</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-2-4-%E5%9C%A8%E7%9B%AE%E6%A0%87bucket%E4%B8%AD%E9%81%8D%E5%8E%86Entry%E7%BB%93%E7%82%B9"><span class="toc-text">1.2.4 在目标bucket中遍历Entry结点</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-3-get-%E6%96%B9%E6%B3%95"><span class="toc-text">1.3 get()方法</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-4-Map%E4%B8%AD%E7%9A%84%E8%BF%AD%E4%BB%A3%E5%99%A8Iterator"><span class="toc-text">1.4 Map中的迭代器Iterator</span></a><ol class="toc-child"><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-1-Map%E9%81%8D%E5%8E%86%E7%9A%84%E5%87%A0%E7%A7%8D%E6%96%B9%E5%BC%8F"><span class="toc-text">1.4.1 Map遍历的几种方式</span></a></li><li class="toc-item toc-level-3"><a class="toc-link" href="#1-4-2-Iterator%E7%9A%84%E5%AE%9E%E7%8E%B0%E5%8E%9F%E7%90%86"><span class="toc-text">1.4.2 Iterator的实现原理</span></a></li></ol></li><li class="toc-item toc-level-2"><a class="toc-link" href="#1-5-fail-fast%E7%AD%96%E7%95%A5"><span class="toc-text">1.5 fail-fast策略</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%8C%E3%80%81JDK8%E4%B8%AD%E7%9A%84HashMap%E5%BA%95%E5%B1%82%E5%AE%9E%E7%8E%B0"><span class="toc-text">二、JDK8中的HashMap底层实现</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#2-1-put-%E6%93%8D%E4%BD%9C"><span class="toc-text">2.1 put()操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-2-%E6%89%A9%E5%AE%B9%E6%93%8D%E4%BD%9C"><span class="toc-text">2.2 扩容操作</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#2-3-get-%E6%93%8D%E4%BD%9C"><span class="toc-text">2.3 get()操作</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%B8%89%E3%80%81HashMap%E3%80%81HashTable%E6%98%AF%E4%BB%80%E4%B9%88%E5%85%B3%E7%B3%BB%EF%BC%9F"><span class="toc-text">三、HashMap、HashTable是什么关系？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#3-1-%E5%85%B1%E5%90%8C%E7%82%B9%E4%B8%8E%E5%BC%82%E5%90%8C%E7%82%B9"><span class="toc-text">3.1 共同点与异同点</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#3-2-HashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E5%AE%89%E5%85%A8"><span class="toc-text">3.2 HashMap的线程安全</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E5%9B%9B%E3%80%81HashMap%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%E5%9C%A8%E5%93%AA%EF%BC%9F"><span class="toc-text">四、HashMap线程不安全在哪？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#4-1-%E6%95%B0%E6%8D%AE%E8%A6%86%E7%9B%96%E9%97%AE%E9%A2%98"><span class="toc-text">4.1 数据覆盖问题</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-2-%E6%89%A9%E5%AE%B9%E6%97%B6%E5%AF%BC%E8%87%B4%E6%AD%BB%E5%BE%AA%E7%8E%AF"><span class="toc-text">4.2 扩容时导致死循环</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#4-3-%E5%B0%8F%E7%BB%93"><span class="toc-text">4.3 小结</span></a></li></ol></li><li class="toc-item toc-level-1"><a class="toc-link" href="#%E4%BA%94%E3%80%81%E5%A6%82%E4%BD%95%E8%A7%84%E9%81%BFHashMap%E7%9A%84%E7%BA%BF%E7%A8%8B%E4%B8%8D%E5%AE%89%E5%85%A8%EF%BC%9F"><span class="toc-text">五、如何规避HashMap的线程不安全？</span></a><ol class="toc-child"><li class="toc-item toc-level-2"><a class="toc-link" href="#5-1-%E5%B0%86Map%E8%BD%AC%E4%B8%BA%E5%8C%85%E8%A3%85%E7%B1%BB"><span class="toc-text">5.1 将Map转为包装类</span></a></li><li class="toc-item toc-level-2"><a class="toc-link" href="#5-2-%E4%BD%BF%E7%94%A8ConcurrentHashMap"><span class="toc-text">5.2 使用ConcurrentHashMap</span></a></li></ol></li></ol>
  </aside>

        
      </div>
    </div>
  </div>
</main>
  

<footer class="footer">
  <div class="footer-social"><a 
        href="tencent://message/?Menu=yes&uin=894519210 "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#12B7F5'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconQQ "></i>
      </a><a 
        href="javascript:; "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#09BB07'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconwechat-fill "></i>
      </a><a 
        href="https://github.com/longshenzhifeijue "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color= '#9f7be1'" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  icongithub-fill "></i>
      </a><a 
        href="mailto:xufei20160601@163.com "
        target="_blank"
        class="footer-social-item"
        onMouseOver="this.style.color=#FF3B00" 
        onMouseOut="this.style.color='#33333D'">
          <i class="iconfont  iconmail"></i>
      </a></div>
  
    <div class="footer-copyright"><p>Powered by <a target="_blank" href="https://hexo.io">Hexo</a>  |  Theme - <a target="_blank" href="https://github.com/longshenzhifeijue">XuFei</a></p></div>
  
</footer>
  
      <div class="fab fab-plus">
    <i class="iconfont iconplus"></i>
  </div>
  
  
  <div class="fab fab-up">
    <i class="iconfont iconcaret-up"></i>
  </div>
  
  
  
    
<script src="/js/color-mode.js"></script>

  
  
</body>

<script src="https://cdn.bootcss.com/jquery/3.4.1/jquery.min.js"></script>



  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.lazyload/1.9.1/jquery.lazyload.min.js"></script>




  
<script src="https://cdnjs.cloudflare.com/ajax/libs/fancybox/3.5.7/jquery.fancybox.min.js"></script>






  
<script src="https://cdn.bootcdn.net/ajax/libs/jquery.qrcode/1.0/jquery.qrcode.min.js"></script>




<script src="/js/utils.js"></script>
<script src="/js/script.js"></script>







  <script>
    (function () {
      var bp = document.createElement('script');
      var curProtocol = window.location.protocol.split(':')[0];
      if (curProtocol === 'https') {
        bp.src = 'https://zz.bdstatic.com/linksubmit/push.js';
      } else {
        bp.src = 'http://push.zhanzhang.baidu.com/push.js';
      }
      var s = document.getElementsByTagName("script")[0];
      s.parentNode.insertBefore(bp, s);
    })();
  </script>













</html>